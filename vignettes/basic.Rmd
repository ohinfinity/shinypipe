---
title: "shinypipe vignette"
author: "Karthik Rajendran"
date: "December, 2017"
output: 
  html_document:
    toc : true
    toc_float : true
    code_folding: hide
runtime: shiny
---

```{r Library, include=F}
rm(list = ls())
library(datasets)
library(data.table)
library(ggplot2)

runWithoutInstall <- T
ifelse(runWithoutInstall,
       sapply(list.files(path = "../R/", pattern="*R", full.names = T), source),
       library(shinypipe))

data(mtcars)
rv <- reactiveValues(table=as.data.table(mtcars))
rm(mtcars)
```

### File upload 1

You can override the default selected values of *sep* and *header*

```{r }
ui.fread("file1")
r.data1 <- callModule(s.fread, "file1")
renderTable(head(r.data1()))
```

### File upload 2

Here, the user is not given the choice to select separator (by setting sep = NULL).
Instead, we can specify *sep* directly in the server function. 
The same may be achieved for header argument as well.
```{r }
ui.fread("file2", sep = NULL)
r.data2 <- callModule(s.fread, "file2", params = list(sep = ","))
renderTable(head(r.data2()))
```

#### Table used in the rest of the vignette

We will either use the preloaded table or whichever table was uploaded the latest from the file upload widgets above.
```{r}
r.data <- reactive(as.data.table(rv$table))
observe(react.val$table <- r.data1())
observe(react.val$table <- r.data2())
renderTable(head(r.data()))
```

### Formula editor

Formulas can be dynamically constructed using column names of the tables

```{r}
renderUI({
  cols <- list(choices = names(r.data()))
  ui.formula("fml", cols, cols, T)
})
```

#### Output formula

```{r}
r.fml <- callModule(s.formula, "fml")
renderPrint(r.fml())
```

Similar to the "File upload 2" example, the choice of whether to include intercept or not
can be hidden from the user by setting intercept to NULL.

### Sample formula usage

Perform a simple regression using the formula

```{r}
renderPrint(summary(lm(r.fml(), r.data())))
```


### Plot widget 

```{r}
r.y <- callModule(s.formula.y, "fml")
r.xVec <- callModule(s.formula.x, "fml")

## TODO change this once ui.formula is upgraded
renderUI(radioButtons("xToPlot", "Choose x to plot", choices = r.xVec(), inline = T))
r.x <- reactive(input$xToPlot)

ui.plot("plot")
r.brushedData <- callModule(s.plot, "plot", reactive(if (!is.null(r.x())) geom_point(aes_string(x=r.x(), y=r.y()))), r.data)

```

### Using Params widget

Fit a generalized linear model

```{r}
ui.params("params",
          family  = list("", c("gaussian", "poisson")))
r.glmParams <- callModule(s.params, "params")

renderPrint({
  f <- do.call(stats::glm, c(list(formula = r.fml(), data = r.data()), r.glmParams()))
  f$coefficients
})

```


