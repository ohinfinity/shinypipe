---
title: "shinypipe vignette"
author: "Karthik Rajendran"
output: 
  html_document:
    toc : true
    toc_float : true
    code_folding: hide
runtime: shiny
---

```{r Library, include=F}
rm(list = ls())
library(datasets)
library(data.table)
library(ggplot2)

runWithoutInstall <- T
ifelse(runWithoutInstall,
       sapply(list.files(path = "../R/", pattern="*R", full.names = T), source),
       library(shinypipe))

data(mtcars)
rv <- reactiveValues(table=as.data.table(mtcars))
rm(mtcars)
```

Vignette to illustrate some elements of R Shiny modules packaged in https://github.com/rajkar86/shinypipe
Click on show all code on the top right to show code.

### File upload 1

*fread* wrapper to get a data.table from a data file

```{r }
ui.fread("file1")
r.data1 <- callModule(s.fread, "file1")
renderTable(head(r.data1()))
```

Note that the default selected values of *sep* and *header* can be overidden.

### File upload 2

The ability to select separator can be taken away from the user (by setting sep = NULL).
In this case, *sep* must be directly specified in the server function. 
The same is true for the header argument as well.

```{r }
ui.fread("file2", sep = NULL)
r.data2 <- callModule(s.fread, "file2", params = list(sep = ","))
renderTable(head(r.data2()))
```

#### Table used in the rest of the vignette

The sample *cars* table is used for illustration, unless a file was uploaded in one of the widgets above, 
in which case the table from the latest uploaded file will be used.

```{r}
r.data <- reactive(as.data.table(rv$table))
observe(rv$table <- r.data1())
observe(rv$table <- r.data2())
renderTable(head(r.data()))
```

### Simple Formula editor

Formulas can be dynamically constructed, for instance, using column names of the tables. 
The user can be restricted to selecting only one explanatory variable by setting the parameter simpleFormula to TRUE.
This can be useful for plots.

```{r}
renderUI({
  colsY <- list(choices = names(r.data())[1:5])
  colsX <- list(choices = names(r.data())[-(1:5)])
  ui.formula("form", colsY, colsX, simpleFormula = T, theme = "small")
})
```

#### Output formula

```{r}
r.form <- callModule(s.formula, "form")
renderPrint(r.form())
```

### Plot widget

Sample usage of simple formula.

```{r}

r.yVal <- callModule(s.formula.y, "form")
r.xVal <- callModule(s.formula.x, "form")

ui.plot("plot")
r.plot <- reactive(geom_point(aes_string(x=r.xVal(), y=r.yVal())))
r.brushedData <- callModule(s.plot, "plot", r.plot, r.data, selected.colname = "selected")

```

#### Selected Data

Show head of the selected data from the above plot. Click and drag in the plot to select data.
Note that if selected.colname is not specified, the data returned will only be the selected data, and there's no need to filter subsequently.

```{r}
renderDataTable(head(r.brushedData()[selected==T]))
```


### Formula editor: example 1

The default formula interface allows selecting multiple explanatory variables. And the user can be given control over whether to use intercept by just setting a default selection for the intercept argument.

```{r}
renderUI({
  colsY <- list(choices = names(r.data()), selected = "mpg")
  colsX <- list(choices = names(r.data()), selected = "wt")
  ui.formula("fml", colsY, colsX, intercept = T)
})
```

#### Output formula

```{r}
r.fml <- callModule(s.formula, "fml")
r.fml.y <- callModule(s.formula.y, "fml")
renderPrint(r.fml())
```

The choice of whether to include intercept or not can be hidden from the user by leaving 
the intercept to its default value of NULL as shown in the "Simple formula editor" example.

### Linear regression (Full table)

Sample usage of formula.

```{r}
renderPrint(summary(lm(r.fml(), r.data())))
```

### Linear regression (Selected)

Using the formula only on the selected dataset. Select a portion of the dataset from the plot above to run linear regression
only on the selected portion of the dataset.

```{r}
renderPrint({
  dt <- r.brushedData()[selected==T]
  if (dt[,.N] == 0)
    return("Brush the points on the graph above to select portion of the dataset")
  summary(lm(r.fml(), dt))
})
```

### Using params: SVM example

Encapsulate UI interface for function parameters without worrying about the widgets to use. Widgets are automatically selected based on type inference; in most cases, users only need to specify a default value and (optionally) a range of allowed values.

The selected parameter values are returned in a list, that can be directly used to call a function through *do.call*. This is a convenient way to group parameters applicable to a specific function.

E.g. Run SVM. Note: not all parameters are applicable for all kernels.

```{r}
library(e1071)
ui.params("params",
          kernel  = list("linear", c("linear", "polynomial", "radial", "sigmoid")),
          cost    = list(1),
          degree  = list(3, c(2,5)),
          gamma   = list(1, c(0,NA)),
          coef0   = list(0, c(0,1), step = .01))

r.svmParams <- callModule(s.params, "params")

r.svmModel <- reactive(do.call(svm, c(list(formula = r.fml(), data = r.data()), r.svmParams())))

renderPrint({f <- r.svmModel(); f$call <- NULL; return(summary(f));})
```


#### RMS error
```{r}
renderPrint(sqrt(mean((predict(r.svmModel()) - r.data()[,r.fml.y(), with=F])^2)))
```

### Using params: Example 2

Just a simple example to illustrate other types of data inputs.

```{r}
ui.params("paramList",
          name  = list("", NA, placeholder = "Enter your name here", width = '100%'),
          dob   = list(Sys.Date()-1, c(NA, Sys.Date()), label = "Date of birth"))
r.paramList <- callModule(s.params, "paramList")

f.age <- function(name, dob) {
  age <- (Sys.Date() - dob)
  if (is.null(name) || name == "") return ("Enter your name above.");
  if (age <= 0) return ("Enter a date in the past");
  return (paste0("You're ", age, " day(s) old, ", name, "."))
} 

renderPrint(do.call(f.age, r.paramList()))
```

### Vector Input

#### Create vector by using expressions like:
* 1:4
* seq(1,20,2) 
* c(1,5,9)
* 2^(-4:4)

```{r}
ui.vector("vec1")
r.vec1 <- callModule(s.vector, "vec1")
renderPrint(r.vec1())
```

